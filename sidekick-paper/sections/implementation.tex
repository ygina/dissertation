\section{Implementation}
\label{sec:implementation}

\input{tables/lines-of-code.tex}

We now describe our implementation of Robin~\cite{sidekick-github} for several applications.
We integrated \sys functionality with a simple media client for low-latency streaming
and an HTTP/3 (QUIC) client.
The total implementation of the quACK library, and proxy and client
integrations used 6363 LOC (\Cref{tab:lines-of-code}).

% \paragraph{QuACK library.}
% Quack library.

\subsection{Baselines and Applications}

The baselines we evaluated against were the performance of two opaque transport
protocols without proxy assistance, and the fairness of a split CUBIC connection.

\paragraph{Low-latency media application.}
We implemented a simple server and client in Rust for streaming low-latency
media. The client sends a numbered packet containing 240 bytes of data every
20 milliseconds, representing an audio stream at 96 kbit/s.
The sequence number is encrypted on the wire.

The server receives packets. If it receives a nonconsecutive sequence number,
it sends a NACK back to the client that contains the sequence number of each
missing packet. The client's behavior on NACK is to retransmit the packet. The
server retransmits NACKs, up to one per RTT, until it has received the packet.

The server's application behavior is to store incoming packets in a buffer
and play them as soon as the next packet in the sequence is available. The
de-jitter buffer delay is the length of time between when the packet is stored
to when it can be played in-order. Some packets can be played immediately.

\paragraph{HTTP/3 file upload application.}
We used the popular \texttt{libcurl}~\cite{libcurl} file transfer library as the basis for
our HTTP client, and an \texttt{nginx} webserver. The client makes an HTTP
POST request to the server. Both are patched with \texttt{quiche}~\cite{quiche}, a production
implementation of the QUIC protocol from Cloudflare, to provide support for
HTTP/3.

For our TCP baselines, we used the same file upload application with the
default HTTP/1.1 server and client. We used a split-connection
TCP PEP~\cite{caini2006pepsal} that intercepts the TCP
SYN packet in the three-way handshake, pretends to be the other side of that
connection, and initiates a new connection to the real endpoint.
Both clients use CUBIC congestion control.

\subsection{Client Integration}

In each application, we modified only the \emph{client} to speak Robin
and respond to in-network feedback. The server remained unchanged.
The modifications were in two parts: following the discovery mechanism to
establish bi-directional communication with the proxy, and using the information
in the quACK to modify transport layer behavior.

\input{tables/experimental-scenarios.tex}

% Recall that clients may respond to end-to-end ACKs in the following ways:
% \begin{enumerate}[noitemsep]
% 	\item Retransmit lost packets.
% 	\item Update the congestion window.
% 	\item Move the sending window.
% 	\item Forget packets in the retransmission buffer.
% \end{enumerate}
% \noindent They can similarly use quACKs to modify the base protocol, with the
% additional knowledge of \emph{where} loss occured.

\paragraph{Low-latency media client.} The media client has two open UDP sockets:
one for the base connection and one for the \sys connection. When it receives a
quACK, it detects lost packets without reordering and immediately retransmits
them. The protocol does not have a congestion window nor a flow-control window.
The client also sends reset and configuration messages over the \sys connection.

\paragraph{HTTP/3 file upload client.}
The HTTP/3 client similarly has an adjacent UDP socket for the \sys connection on
which it receives quACKs and sends reset and configuration messages. The client
passes the quACK to our modified \texttt{quiche} library, which interprets the
quACK and makes transport layer decisions. From the client's perspective,
\texttt{quiche} tells \texttt{libcurl} exactly what bytes to send over the wire.

Our modified \texttt{quiche} library uses the quACK to inform the
retransmission behavior, congestion window, and flow-control window. The library
immediately retransmits lost \emph{frames} in a newly-numbered
packet, as opposed to the lost \emph{packet}, similar to QUIC's original
retransmission mechanism. We implement PACUBIC,
described in \Cref{sec:design:cubic}.
We also move the flow-control window (without forgetting packets in the
retransmission buffer), but only in the ACK reduction scenario, when the
congestion window is nearly representative of that of the \sys connection's
path segment.

% For the \sys receiver, we augmented \texttt{quiche}~\cite{quiche}, a production
% implementation of the QUIC protocol from Cloudflare, and the popular
% \texttt{curl} HTTP/3 client patched with \texttt{quiche}.
% We modified 967 LOC in the \texttt{curl} C integration and
% 557 LOC in the \texttt{quiche} Rust integration.

% Over the course of working with quiche, we discovered and raised several bugs
% in the quiche implementation with its maintainers, including flow control
% limit negotiation, congestion window size calculation, and interpretations of
% the spec for detecting spurious loss congestion events [citations omitted].
% % \michael{should this be replaced with: ``removed for anonymity''?
% % Note, in this case, we should also remove the later text where you describe the spurious case in greater detail and again say that we pointed it out to the devs.}
% We are still able to show that quiche (and its CUBIC implementation) generally
% matches the behavior and performance of TCP end-to-end, but inevitably there
% will be differences due to the experimental nature of QUIC.

\subsection{Proxy Integration}
\label{sec:implementation:proxy}

Our proxy sniffs incoming packets of a network interface using the
\texttt{recvfrom} system call on a raw socket.
It stores a hash table using Rust's standard library \texttt{HashMap} that maps
socket pairs to their respective quACKs, and
incrementally updates the quACKs for flows that have requested \sys assistance.
It also sends quACKs at their configured frequencies and listens for
configuration messages.

% There are several alternative designs. The proxy could also parse packets
% directly from the kernel using, e.g., eBPF, or process packets directly in the
% data plane. These designs could be faster, but more difficult to implement.
% Instead of quACKing in a separate UDP stream, the proxy could piggyback quACKs
% onto the existing stream. However, this would depend on the message frequency
% in the base connection, and could also cause the packet size to exceed the MTU.
